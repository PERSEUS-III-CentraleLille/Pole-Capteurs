import os
from time import sleep

MTU_Sizes = [600,2000,3200,6000,12800,24000,35600,49600,59400,65520]   # à revoir - les Mathis
for i, MTU_Size in zip(range(len(MTU_Sizes)), MTU_Sizes):
    dossier = "/home/pi/Documents/Pole-Capteurs-main/client"
    filename = "client_" + str(i)
    file = str(dossier) + "/" + str(filename) + ".c"

    f = open(file, "w")

    print("#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/l2cap.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\ntypedef struct {\n    char ** data;		//Ensemble de données\n    int sizeLines;		//Nombre de lignes de données\n    int sizeColumns;	//Nombre de colonnes de données\n    int missingLines;	//Nombre de lignes incomplètes\n} data_lines;\n\ndata_lines DataConvert ( char * lien ){    //Fonction de conversion des fichiers txt en char **\n\n    //Ouverture du fichier\n    FILE * fichier = fopen(lien, \"r\");\n\n    //Initialisations\n    data_lines dataConverted;\n    char ** data;\n    dataConverted.data = NULL;\n    dataConverted.sizeColumns, dataConverted.sizeLines, dataConverted.missingLines = 0;\n    int sizeColumns, sizeLines = 0;\n    char currentChar;    				//Caractère lu actuellement\n    int c1 = 1;  						//Compteur de lignes\n    int c2 = 1;  						//Compteur de colonnes\n    int c3 = 0;  						//Compteur annexe\n\n    //Allocation mémoire initiale\n    data = (char **) malloc (c1 * sizeof(char *));\n    data[c1 - 1] = (char *) malloc (c2 * sizeof(char));\n    while ( ! feof(fichier)) {  		//Tant qu'on est pas arrivés à la fin du fichier\n\n        //Récupération du caractère lu\n        currentChar = fgetc(fichier);\n        int currentInt = currentChar;\n\n        if (currentInt == 10) {    		//Si on a un saut de ligne (car int \"\\n\" = 10)\n\n            c1++;\n\n            if (c1==2){      \n                c3 = c2;       			//Stockage du nombre de colonnes \"normal\" du fichier\n                dataConverted.sizeColumns = c3;\n            } else {\n                if (c2 == c3 + 1 || c2 == c3 + 2 || c2 == c3 + 3 || c2 == c3 - 1 || c2 == c3 - 2 || c2 == c3 - 3){    \n										// Présence (ou non) des - dans les données\n                    c3 = c2;     		//Stockage du nouveau nombre \"normal\" de colonnes\n                    dataConverted.sizeColumns = c3;\n                }\n                if (c2 != c3){\n                    printf(\"Il manque %d caracteres dans la ligne %d du fichier %s\\n\", abs(c2-c3), c1-1, lien);\n                    dataConverted.missingLines++;\n                }\n            }\n            c2 = 1;      				//Retour à la première colonne\n\n            //Réallocation mémoire pour la nouvelle ligne\n            data = (char **) realloc (data, c1 * sizeof(char *));\n            data [c1 - 1] = (char *) malloc (c2 * sizeof(char));\n        } else {\n\n            c2++;\n\n            //Réallocation mémoire pour la nouvelle colonne\n            data[c1 - 1] = (char *) realloc (data[c1 - 1], c2 * sizeof(char));\n            data[c1 - 1][c2 - 2] = currentChar;\n        }\n    }\n\n    dataConverted.data = data;\n    dataConverted.sizeLines = c1;\n    return dataConverted;\n}\n	 \nint set_l2cap_mtu( int s , uint16_t mtu ) { //Fonction qui change le MTU d'un socket\n\n	struct l2cap_options opts ;\n	int optlen = sizeof(opts ) ;\n	int status = getsockopt(s, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen);\n	if( status == 0) {\n		opts.omtu = opts.imtu = mtu ;\n		status = setsockopt( s , SOL_L2CAP , L2CAP_OPTIONS , &opts ,optlen ) ;\n	}\n	return status ;\n};\n\nint envoie(data_lines data){   //Fonction d'envoi de données\n\n	//Création du socket dans le but de connecter entre elles les 2 raspberry\n	struct sockaddr_l2 addr = { 0 } ;\n	int s , status ;\n	char dest[18] = \"DC:A6:32:78:6C:7E\";\n	\n	//Allocation du socket\n	s = socket(AF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP) ;\n\n	//Modification du MTU\n", file=open(file,"a"))

                
    print("	int mtu_value = " + str(MTU_Size) + ";    										//Valeur modifiée par le fichier python\n", file=open(file, "a"))

    print("\n   	set_l2cap_mtu( s , mtu_value );\n\n	//Connexion entre les 2 raspberry\n	addr.l2_family = AF_BLUETOOTH;\n	addr.l2_psm = htobs(0x1001);\n	str2ba( dest , &addr.l2_bdaddr ) ;\n	status = connect (s , (struct sockaddr *)&addr , sizeof(addr ));\n\n	//Initialisations d'envoi\n	int i,j = 0;\n	struct timeval start, end;  									//Initialisation de variables de temps\n	char paquet[mtu_value];\n	memset(paquet,0,mtu_value * sizeof(char));  					//Initialisation du paquet avec des zéros\n	\n	//Envoi de données\n	if( 0 == status ) {\n		printf(\"Connexion réussie\\n\");\n		gettimeofday(&start, NULL);									//Initialisation du temps de départ\n		int nb_data = 0;               								//Nombre de données déjà inscrites dans le paquet\n		for (i=0; i<data.sizeLines;i++){\n		    if ((nb_data+data.sizeColumns) >= mtu_value){        	//On prend le parti de ne pas transmettre des bouts partiels de ligne\n				send(s, paquet, sizeof(paquet), 0);             	//Envoi du paquet\n				memset(paquet,0,mtu_value * sizeof(char));  		//Initialisation du paquet avec des zéros\n				nb_data = 0;                                    	//Remise à zéro du nombre de données dans le paquet\n		    }\n		    int j=0;\n		    int c = data.data[i][j];\n		    while(c == 101 || c == 43 || c == 46 || c == 32 || c == 45 || (c >= 48 && c <= 57)){	\n																	//Si le caractère correspond aux données à transmettre\n				paquet[nb_data] = data.data[i][j];   				//Ajout du caractère à paquet\n				nb_data++;                          				//Incrémentation du nombre de données ajoutées à paquet\n				j++;\n				c = data.data[i][j];\n		    }\n		    char arobase = 64;\n		    paquet[nb_data] = arobase;								//Ajout d'un @ en tant que saut de ligne\n		    nb_data++;\n		}		\n		send(s,\"stop\",4,0);  										//Fin de la transmission du fichier\n		gettimeofday(&end, NULL);									//Initialisation du temps de fin\n		printf(\"Temps de transmission : %ld micro seconds\\n\",\n		((end.tv_sec * 1000000 + end.tv_usec) -\n		(start.tv_sec * 1000000 + start.tv_usec)));  				//Temps total de transmission\n	}\n	if( status < 0 ) {\n		fprintf(stderr, \"error code %d: %s\\n\", errno, strerror(errno));\n		perror( \"Connexion echouée\\n\" );\n	}\n	close (s);  													//Fermeture du socket\n	return 0;\n}\n\nint main(int argc , char ** argv){\n\n	data_lines data;\n	data = DataConvert(\"/home/pi/Documents/Pole-Capteurs-main/client/Numerical_Results_capteur_v1.txt\");\n	envoie(data);\n	\n}\n", file=open(file, "a"))
