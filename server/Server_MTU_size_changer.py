import os

MTU_Sizes = [7810,15620,31040]
for i, MTU_Size in zip(range(len(MTU_Sizes)), MTU_Sizes):
    
    dossier = "C:/Users/flaph/OneDrive/Documents/GitHub-PERSEUS/Pole-Capteurs/server"
    filename = "serverMTU_Changed_" + str(i)
    file = str(dossier) + "/" + str(filename) + ".c"

    f = open(file, "w")

    #MTU_Size = 15620

    print("#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/l2cap.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/time.h>\n#include <pthread.h>\n\n/*pthread_attr_t tattr1;  // Creation d'un attribut de thread\nset_thread_param(&tattr1);                                                               // Appel a la fonction definisant le type de scheduling\nstruct sched_param param1;                                                               // Creation d'un parametre de scheduling\nparam1.sched_priority = 5;                                                              // Definition de la valeur de priorite temps reel pour les threads\n               \nerr = pthread_attr_setschedparam (&tattr1, &param1);                                 // Affectation d'une priorite temps reel au parametre tattr a partir de la valeur definie precedemment\nif (err != 0)  {                                                                   // Si l'affectation de la priorite s'est termine avec une erreur\n    handle_error_en(err, \"pthread_attr_setschedparam\");                     // Afficher un message d'erreur dans la console\n}*/\n\nint set_l2cap_mtu( int s , uint16_t mtu ) {\n	struct l2cap_options opts ;\n	int optlen = sizeof(opts );\n	int status = getsockopt ( s , SOL_L2CAP , L2CAP_OPTIONS , &opts ,&optlen ) ;\n	if( status == 0) {\n		opts . omtu = opts . imtu = mtu ;\n		status = setsockopt( s , SOL_L2CAP , L2CAP_OPTIONS , &opts ,optlen ) ;\n	}\n	return status ;\n}\n\nchar ** DataConvert ( char * lien ){\n\n	//ouverture fichier\n	FILE * fichier = fopen(lien, \"r\");\n\n	assert (fichier != NULL);\n\n	char ** data;\n	int i,j,k,ind;\n\n	//allocation memoire\n	data = (char **)malloc(6248 * sizeof(char *));\n	for (i= 0; i < 6248; i++){\n		data[i] = (char *)malloc(130 * sizeof(char ));\n	}\n	//lecture fichier\n	char chaine[130]; // cdc correspondant a 1 ligne\n	for(i=0;i<6248;i++){\n		fgets (chaine, 130, fichier);\n		strcpy(data[i], chaine);\n		memset (chaine, 0, 130);\n	}\n	return data;\n}\n\nint sizeLines(char ** data){\n    int size = 0;\n    while (data[size] != NULL) {\n        size++;\n    }\n    return size;\n}\n\nint sizeColumns(char ** data, int i){\n    int size = 0;\n    while (data[i][size]) {\n        size++;\n    }\n    return size;\n}\n\n//Fonction taux d'erreur\n\nfloat Error_Rate_Fct(char * final_data, char * initial_data){\n\n    // Ouverture du fichier envoye\n    char ** data_i = DataConvert(initial_data);\n\n    // Ouverture du fichier recu\n    char ** data_f = DataConvert(final_data);\n\n    float nb_errors = 0;\n    float nb_data = 0;\n\n    int i = 0;\n    int j = 0;\n\n    // Recuperation du nombre de lignes\n    int nb_lignes_i = sizeLines(data_i);\n    for (i=0;i<nb_lignes_i;i++){\n        //Recuperation du nombre de colonnes\n        int nb_colonnes_i = sizeColumns(data_i,i);\n        for (j=0;j<nb_colonnes_i;j++){\n		    nb_data++;\n		    if (data_i[i][j] != data_f[i][j]){\n			    nb_errors++;	// On compte le nombre d'erreurs dans la fonction\n		    }\n	    }\n    }\n\n    // Calcul du taux d'erreur\n    float error_rate = nb_errors / nb_data * 100;\n    return error_rate;\n}\n\n//Fonction taux de pertes\n\nfloat loss_rate_Fct(char * final_data, char * initial_data){\n\n    // Ouverture du fichier envoye\n    char ** data_i = DataConvert(initial_data);\n\n    // Ouverture du fichier recu\n    char ** data_f = DataConvert(final_data);\n\n    float nb_loss = 0;\n    float nb_data = 0;\n\n    int i = 0;\n    int j = 0;\n\n    int nb_lignes_i = sizeLines(data_i);\n    int nb_lignes_f = sizeLines(data_f);\n\n    if (nb_lignes_i > nb_lignes_f) {\n        nb_loss = nb_loss + (nb_lignes_i - nb_lignes_f);\n        nb_data = nb_lignes_i * 5;\n        int nb_donnees_f = sizeColumns(data_f,nb_lignes_f-1);   //on prend la derniere ligne\n        nb_loss = nb_loss + (5-nb_donnees_f);   //en gros on verifie que la derniere soit bien composee de 5 donnees sinon on ajoute\n\n    } else if (nb_lignes_i < nb_lignes_f) {\n        nb_loss = nb_loss + (nb_lignes_f - nb_lignes_i);\n        nb_data = nb_lignes_f * 5;\n        int nb_donnees_i = sizeColumns(data_i,nb_lignes_i-1);   //on prend la derniere ligne\n        nb_loss = nb_loss + (5-nb_donnees_i);   //en gros on verifie que la derniere soit bien composee de 5 donnees sinon on ajoute\n    \n    } else {\n        nb_loss = 0;\n        nb_data = 100;    // arbitraire pour eviter la division par 0\n    }\n\n    float loss_rate = nb_loss / nb_data * 100;\n    return loss_rate;\n\n}\n\nint main(int argc , char ** argv){\n	struct sockaddr_l2 loc_addr = { 0 } , rem_addr = { 0 } ;\n	char buf[10000] = { 0 } ;\n	int s, client , bytes_read ;\n	unsigned int opt = sizeof(rem_addr ) ;\n	int i,j;\n	char ** data;\n	int n = 6248;\n	char test[10000] = { 0 } ;\n	\n	//Definition de la priorite du script en priorite temps reel\n\n	struct sched_param sched_p;                                                                 // Creation d'une structure d'ordonancement temps reel pour le programme\n\n	sched_p.sched_priority = 5;                                                                             // Affectation d'une priorite temps reel entre 0 et 99\n\n	if(sched_setscheduler(0, SCHED_RR, &sched_p) == -1)  {                                            // Affectation d'un ordonancement Round-robin avec le parametre de priorite defini precedemment si l'operation se passe sans erreur\n\n		perror (\"sched_setscheduler \\n\");                                                             // Sinon le programme se termine via la fonction perror()\n\n	}\n\n	FILE* fichier = NULL;\n	fichier = fopen(\"test.txt\", \"w+\");\n	// char *** datadebase = DataConvert (lien);\n\n	FILE* resultat = NULL;\n	resultat = fopen(\"result.txt\",\"a\"); \n\n	//allocation memoire\n	data = (char **)malloc(6248 * sizeof(char *));\n	for (i=0; i<15; i++){\n		data[i] = (char *)calloc(4200 , sizeof(char));\n	}\n\n	//creation socket\n	s = socket ( AF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP );", file=open(file, "a"))

    print("\n    set_l2cap_mtu( s , " + str(MTU_Size) + " );\n", file=open(file, "a"))

    print("\n    // bind socket to port 5 of the first available bluetooth adapter\n    loc_addr.l2_family = AF_BLUETOOTH;\n    loc_addr.l2_bdaddr = *BDADDR_ANY;\n    loc_addr.l2_psm = htobs(0x1001);\n\n    bind(s, (struct sockaddr *)&loc_addr, sizeof(loc_addr));\n\n\n    // put socket into listening mode\n    listen (s, 1);\n\n    // accept one connection\n    client = accept (s , (struct sockaddr *)&rem_addr , &opt ) ;\n\n\n\n    ba2str ( &rem_addr.l2_bdaddr , buf ) ;\n\n    fprintf(stderr , \"accepted connection from %s\\n\" , buf ) ;\n    memset(buf , 0, sizeof(buf ));\n\n    // read data from the client\n\n    int check = 1;\n    i=0;\n    int k = 1;\n    long tempsboucle = 0;\n    long temps_envoi = 0;\n    struct timeval start, end;\n    gettimeofday(&start, NULL);\n    while(check) {\n        bytes_read = recv (client , buf , sizeof(buf), 0);\n        if( bytes_read > 0 ) {\n            if( strcmp(buf, \"stop\") == 0 ){\n			    check = 0;\n		    } else if(strcmp(buf, \"next\") == 0){\n			    gettimeofday(&end, NULL);\n			    temps_envoi = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));\n			    tempsboucle+= temps_envoi;\n			    printf(\"Temps pour n = %d : %ld micro seconds\\n\",k, temps_envoi);\n			    fprintf(resultat, \"%d : %ld ms\\n\",k, temps_envoi);\n			    k++;\n			    gettimeofday(&start, NULL);\n		    }else{\n			    strcpy(test, buf);\n			    if (fichier != NULL){\n				    fprintf(fichier, \"%s\", test);\n				    //printf(\"%s \\n\", test);\n			    }\n		    }\n		    memset(buf , 0, sizeof(buf ));\n	    }\n    }\n    gettimeofday(&end, NULL);\n    tempsboucle += ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));\n    printf(\"Temps total moyen : %ld micro seconds\\n\", tempsboucle/10) ;\n    fprintf(resultat, \"Moyenne : %ld ms \\n\", tempsboucle/10);\n\n    char * initial_data = \"/home/pi/Documents/Numerical_Results_capteur.txt\";\n    char * final_data = \"/home/pi/Documents/test.txt\";\n\n    float marge = 0; 	//marge d'erreur acceptable, a definir\n    float loss_rate = loss_rate_Fct(final_data, initial_data);\n    printf(\"Taux de perte : %f pourcents \\n\", loss_rate);\n\n    if (loss_rate <= marge) {\n	    float error_rate = Error_Rate_Fct(final_data, initial_data);\n	    printf(\"Taux d'erreur : %f pourcents \\n\", error_rate);\n    }\n\n    close (client) ;\n    close (s) ;\n}", file=open(file, "a"))

    os.system("gcc -o " + str(filename) + " " + str(filename) + ".c -lbluetooth")
    os.system("./"+str(filename))