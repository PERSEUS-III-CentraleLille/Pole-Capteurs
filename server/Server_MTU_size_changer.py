import os
from time import sleep

MTU_Sizes = [600,2000,3200,6000,12800,24000,35600,49600,59400,65520]   # à revoir - les Mathiss
TransmissionRate = []
for i, MTU_Size in zip(range(len(MTU_Sizes)), MTU_Sizes):
    
    dossier = "/home/pi/Documents/Pole-Capteurs-main/server"
    filename = "server_" + str(i)
    file = str(dossier) + "/" + str(filename) + ".c"

    f = open(file, "w")

    #MTU_Size = 15620
    
    print("#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/l2cap.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sched.h>\n\ntypedef struct {\n    char ** data;		//Ensemble de données\n    int sizeLines;		//Nombre de lignes de données\n    int sizeColumns;	//Nombre de colonnes de données\n    int missingLines;	//Nombre de lignes incomplètes\n} data_lines;\n\nint set_l2cap_mtu( int s , uint16_t mtu ) { //Fonction qui change le MTU d'un socket\n\n	struct l2cap_options opts ;\n	int optlen = sizeof(opts ) ;\n	int status = getsockopt(s, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen);\n	if( status == 0) {\n		opts.omtu = opts.imtu = mtu ;\n		status = setsockopt( s , SOL_L2CAP , L2CAP_OPTIONS , &opts ,optlen ) ;\n	}\n	return status ;\n}\n\ndata_lines DataConvert ( char * lien ){    	//Fonction de conversion des fichiers txt en char **\n\n    //Ouverture du fichier\n    FILE * fichier = fopen(lien, \"r\");\n\n    //Initialisations\n    data_lines dataConverted;\n    char ** data;\n    dataConverted.data = NULL;\n    dataConverted.sizeColumns, dataConverted.sizeLines, dataConverted.missingLines = 0;\n    int sizeColumns, sizeLines = 0;\n    char currentChar;    					//Caractère lu actuellement\n    int c1 = 1;  							//Compteur de lignes\n    int c2 = 1;  							//Compteur de colonnes\n    int c3 = 0;  							//Compteur annexe\n\n    //Allocation mémoire initiale\n    data = (char **) malloc (c1 * sizeof(char *));\n    data[c1 - 1] = (char *) malloc (c2 * sizeof(char));\n\n    while ( ! feof(fichier)) {  			//Tant qu'on est pas arrivés à la fin du fichier\n\n        //Récupération du caractère lu\n        currentChar = fgetc(fichier);\n        int currentInt = currentChar;\n\n        if (currentInt == 10) {    			//Si on a un saut de ligne (car int \"\\n\" = 10)\n\n            c1++;\n\n            if (c1==2){      \n                c3 = c2;       				//Stockage du nombre de colonnes \"normal\" du fichier\n                dataConverted.sizeColumns = c3;\n            } else {\n                if (c2 == c3 + 1 || c2 == c3 + 2 || c2 == c3 + 3 || c2 == c3 - 1 || c2 == c3 - 2 || c2 == c3 - 3){    \n											// Présence (ou non) des - dans les données\n                    c3 = c2;     			//Stockage du nouveau nombre \"normal\" de colonnes\n                    dataConverted.sizeColumns = c3;\n                }\n                if (c2 != c3){\n                    printf(\"Il manque %d caracteres dans la ligne %d du fichier %s\\n\", abs(c2-c3), c1-1, lien);\n\n                    dataConverted.missingLines++;\n                }\n            }\n            c2 = 1;      					//Retour à la première colonne\n\n            //Réallocation mémoire pour la nouvelle ligne\n            data = (char **) realloc (data, c1 * sizeof(char *));\n            data [c1 - 1] = (char *) malloc (c2 * sizeof(char));\n\n        } else {\n\n            c2++;\n\n            //Réallocation mémoire pour la nouvelle colonne\n            data[c1 - 1] = (char *) realloc (data[c1 - 1], c2 * sizeof(char));\n            data[c1 - 1][c2 - 2] = currentChar;\n        }\n    }\n\n    dataConverted.data = data;\n    dataConverted.sizeLines = c1;\n    \n    return dataConverted;\n}\n\nint errorRate(data_lines data1, data_lines data2) {    //Fonction calculant le taux de perte et d'erreur dans la transmission\n\n    //Initialisations\n    float nb_errors, nb_data = 0;\n    double loss_rate, error_rate = 0.0;\n    int minLines, maxColumns, deltaLines = 0;\n\n    //Transformations en float (pour les divisions)\n    float Lines1 = data1.sizeLines;\n    float mLines1 = data1.missingLines;\n    float Lines2 = data2.sizeLines;\n    float mLines2 = data2.missingLines;\n    \n    //Calcul du taux de perte\n    if (Lines1 >= Lines2){   							//Le fichier 1 est plus long que le 2 (ou de même taille)\n        loss_rate = (Lines1 - Lines2) / Lines1 * 100;\n        minLines = Lines2;\n        deltaLines = Lines1 - Lines2;\n        maxColumns = data1.sizeColumns;\n    } else {				 							//Le fichier 2 est plus long que le 1\n        loss_rate = (Lines2 - Lines1) / Lines2 * 100;\n        minLines = Lines1;\n        deltaLines = Lines2 - Lines1;\n        maxColumns = data1.sizeColumns;\n    }\n\n    //Calcul du taux de perte de données\n    printf(\"Taux de perte de %.10lf pourcents\\n\", loss_rate);\n\n    //Initialisations\n    int i, j = 0;\n\n	//Calcul du taux d'erreur\n    for (i=0;i<minLines;i++){    						//On doit prendre la plus petite longueur de fichier pour éviter de parcourir un fichier fini\n        for (j=0;j<maxColumns;j++){\n            nb_data++;\n            if (data1.data[i][j] != data2.data[i][j]){ 	//Si les char sont différents\n                nb_errors++;\n            }\n        }\n    }\n\n    //Ajout des lignes manquantes (car on a pris la plus petite longueur de fichier possible)\n    nb_errors += deltaLines * maxColumns;\n    \n    //Calcul du taux d'erreur dans les données\n    error_rate = nb_errors / nb_data * 100;\n    printf(\"Taux d'erreur de %.10lf pourcents\\n\", error_rate);\n\n    return 0;\n}\n\nint main(int argc , char ** argv){   //Fonction de réception des données\n\n	//Création du socket de réception et initialisations des données\n	struct sockaddr_l2 loc_addr = { 0 } , rem_addr = { 0 } ; 	// struct de socket\n	int s=0, client , bytes_read ;\n	unsigned int opt = sizeof(rem_addr ) ;\n	\n	//Création du data_lines final\n	data_lines data;\n	data.data = (char **) malloc (sizeof(char*));\n	data.data[0] = (char *) malloc (sizeof(char));\n	data.data[0][0] = '\\0';\n\n	//Définition de la priorité du script en priorité temps réel\n	struct sched_param sched_p;									// Création d'une structure d'ordonancement temps réel pour le programme\n	sched_p.sched_priority = 50;                				// Affectation d'une priorité temps réel entre 0 et 99\n	if(sched_setscheduler(0, SCHED_RR, &sched_p) == -1)  {   	// Affectation d'un ordonancement Round-robin avec le paramètre de priorité défini précédemment si l'opération se passe sans erreur\n		perror (\"sched_setscheduler \\n\");       				// Sinon le programme se termine via la fonction perror()\n	}\n\n	//Allocation du socket\n	s = socket ( AF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP );\n	loc_addr.l2_family = AF_BLUETOOTH;\n	loc_addr.l2_bdaddr = *BDADDR_ANY;\n	loc_addr.l2_psm = htobs(0x1001);\n	bind(s, (struct sockaddr *)&loc_addr, sizeof(loc_addr));\n	listen (s, 1);\n	\n	//Modification du MTU\n", file=open(file, "a"))
	
    print("	int mtu_value = "+ str(MTU_Size) +";										//Valeur modifiée par le fichier python\n", file=open(file, "a"))

    print("	set_l2cap_mtu(s , mtu_value );\n	\n	//Conversion du fichier initial\n	data_lines initial_data;\n	initial_data = DataConvert(\"/home/pi/Documents/Numerical_Results_capteur.txt\");\n\n	//Initialisations de réception\n	char buf[mtu_value];\n	memset(buf,0,mtu_value * sizeof(char));   					//Initialisation du buffer avec des zéros\n	char test[mtu_value];\n	memset(test,0,mtu_value * sizeof(char));   					//Initialisation de test avec des zéros\n\n	//Ouverture du fichier de résultat et du fichier de réception des données\n	FILE* fichier = NULL;\n	fichier = fopen(\"test.txt\", \"w+\");\n	FILE* resultat = NULL;\n	resultat = fopen(\"result.txt\",\"w+\"); \n\n	//Acceptation de la connexion entre les Raspberry\n	client = accept (s , (struct sockaddr *)&rem_addr , &opt ) ;\n	ba2str ( &rem_addr.l2_bdaddr , buf ) ;\n	fprintf(stderr , \"accepted connection from %s\\n\" , buf ) ;\n	memset(buf , 0, sizeof(buf ));\n\n	//Réception de données\n	int check = 1;\n	int i, j, final_j = 0;\n	long tempsboucle, temps_envoi = 0;\n	struct timeval start, end;									//Initialisation de variables de temps\n\n	gettimeofday(&start, NULL);									//Initialisation du temps de fin\n	while(check) {\n		bytes_read = recv (client , buf , mtu_value, 0); 		//Réception des données du client\n		if( bytes_read > 0 ) {\n			if( strcmp(buf, \"stop\") == 0 ){						//Quand on est arrivés à la fin de l'envoi\n				check = 0;\n				gettimeofday(&end, NULL);   					//Initialisation du temps de fin\n				temps_envoi = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));\n				printf(\"\\nTemps de transmission : %ld micro secondes\\n\\n\", temps_envoi);  \n																//Temps total de transmission\n				fprintf(resultat, \"%ld ms\\n\",temps_envoi);\n			}else{\n				strcpy(test, buf);   							//Copie du buffer vers la mémoire \"test\"\n				if (fichier != NULL){\n					fprintf(fichier, test);						//On écrit dans le fichier la mémoire \"test\"\n					int l=0;\n					for (l=0; l<bytes_read; l++){				//Pour chaque caractère lu\n						if (test[l] == '@'){					//Si on a un saut de ligne\n							data.data[i][j] = '\\n';\n							i++;\n							if (j > final_j && i>1){\n							    final_j = j;       				//Afin de déterminer le nombre de colonnes maximal\n							}\n							j=0;\n							data.data = (char **) realloc (data.data, (i+1) * sizeof(char *));		\n																//Réallocation d'une nouvelle ligne\n							data.data[i] = (char *) malloc (sizeof(char));\n						} else if (test[l] == '\\0') {			//Si on est à la fin des données\n							data.data[i][j] = '\\0';\n							l = bytes_read;\n							data.sizeLines = i;   				//Initialisation des derniers paramètres de data_lines\n							data.sizeColumns = final_j;\n							data.missingLines = 0;    			// Il faudrait rajouter une vérification des lignes incomplètes\n						} else {\n							data.data[i][j] = test[l];			//Ajout au data\n							j++;\n							data.data[i] = (char *) realloc (data.data[i], (j+1) * sizeof(char));	\n																//Réallocation mémoire\n						}\n					}\n				}\n			}\n			memset(buf , 0, sizeof(buf ));\n		}\n	}\n\n	//Fermeture des fichiers\n	fclose(resultat);\n	fclose(fichier);\n	\n	//Taille des data_lines\n	printf(\"Taille du fichier initial : %d x %d\\n\", initial_data.sizeLines, initial_data.sizeColumns);\n	printf(\"Taille du fichier final : %d x %d\\n\\n\", data.sizeLines, data.sizeColumns);\n	\n	//Calcul du taux de perte et d'erreur\n	errorRate(initial_data,data);\n\n	//Fermeture des sockets\n	close (client) ;\n	close (s) ; \n}\n",file = open(file,"a"))

    
